using System.Collections.Generic;
using System.Linq;
using System.Text;
using ExperimentFramework.Generators.Models;
using Microsoft.CodeAnalysis;

namespace ExperimentFramework.Generators.CodeGen;

/// <summary>
/// Builds complete proxy class implementations from experiment definitions.
/// </summary>
internal static class ProxyClassBuilder
{
    /// <summary>
    /// Generates a complete proxy class for a service interface.
    /// </summary>
    public static string GenerateProxyClass(ExperimentDefinitionModel experiment)
    {
        var serviceType = experiment.ServiceType;
        GetProxyClassName(serviceType);
        var proxyClassDeclaration = GetProxyClassDeclaration(serviceType);
        var serviceTypeName = serviceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file is generated by ExperimentFramework.Generators");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Usings
        AppendUsings(sb);
        sb.AppendLine();

        // Namespace
        sb.AppendLine("namespace ExperimentFramework.Generated");
        sb.AppendLine("{");

        // Class declaration
        sb.AppendLine($"    internal sealed class {proxyClassDeclaration} : {serviceTypeName}");
        sb.AppendLine("    {");

        // Fields
        AppendFields(sb);
        sb.AppendLine();

        // Constructor (use simple name without backticks)
        var constructorName = GetProxyConstructorName(serviceType);
        AppendConstructor(sb, constructorName);
        sb.AppendLine();

        // Methods (one per interface method)
        AppendMethods(sb, experiment);
        sb.AppendLine();

        // Helper methods
        AppendSelectionHelper(sb, experiment);
        sb.AppendLine();
        AppendErrorPolicyHelper(sb, experiment);

        // Close class
        sb.AppendLine("    }");

        // Close namespace
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates the proxy class name from the service type name.
    /// Strips 'I' prefix and adds 'ExperimentProxy' suffix.
    /// </summary>
    /// <remarks>
    /// For non-generic types: "MyDatabaseExperimentProxy"
    /// For generic types: "GenericRepositoryExperimentProxy`1" (for reflection)
    /// </remarks>
    public static string GetProxyClassName(INamedTypeSymbol serviceType)
    {
        var name = serviceType.Name;

        // Strip 'I' prefix: IMyDatabase -> MyDatabase
        if (name.StartsWith("I") && name.Length > 1 && char.IsUpper(name[1]))
        {
            name = name.Substring(1);
        }

        // Add suffix
        name += "ExperimentProxy";

        // Handle generics: IRepository`1 -> RepositoryExperimentProxy`1
        if (serviceType.IsGenericType)
        {
            var arity = serviceType.TypeParameters.Length;
            name += $"`{arity}";
        }

        return name;
    }

    /// <summary>
    /// Generates the proxy class declaration with type parameters for source code.
    /// </summary>
    /// <remarks>
    /// For non-generic types: "MyDatabaseExperimentProxy"
    /// For generic types: "GenericRepositoryExperimentProxy&lt;T&gt;" (for class declaration)
    /// </remarks>
    private static string GetProxyClassDeclaration(INamedTypeSymbol serviceType)
    {
        var name = serviceType.Name;

        // Strip 'I' prefix: IMyDatabase -> MyDatabase
        if (name.StartsWith("I") && name.Length > 1 && char.IsUpper(name[1]))
        {
            name = name.Substring(1);
        }

        // Add suffix
        name += "ExperimentProxy";

        // Handle generics: IRepository<T> -> GenericRepositoryExperimentProxy<T>
        if (serviceType.IsGenericType)
        {
            var typeParams = string.Join(", ", serviceType.TypeParameters.Select(tp => tp.Name));
            name += $"<{typeParams}>";
        }

        return name;
    }

    /// <summary>
    /// Generates the constructor name (simple name without backticks or type parameters).
    /// </summary>
    /// <remarks>
    /// For all types: "MyDatabaseExperimentProxy" or "GenericRepositoryExperimentProxy" (no backticks, no type params)
    /// </remarks>
    private static string GetProxyConstructorName(INamedTypeSymbol serviceType)
    {
        var name = serviceType.Name;

        // Strip 'I' prefix: IMyDatabase -> MyDatabase
        if (name.StartsWith("I") && name.Length > 1 && char.IsUpper(name[1]))
        {
            name = name.Substring(1);
        }

        // Add suffix
        name += "ExperimentProxy";

        // For constructors, we never include backticks or type parameters
        return name;
    }

    private static void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("using Microsoft.FeatureManagement;");
        sb.AppendLine("using ExperimentFramework;");
        sb.AppendLine("using ExperimentFramework.Decorators;");
        sb.AppendLine("using ExperimentFramework.Models;");
        sb.AppendLine("using ExperimentFramework.Telemetry;");
    }

    private static void AppendFields(StringBuilder sb)
    {
        sb.AppendLine("        private readonly Microsoft.Extensions.DependencyInjection.IServiceScopeFactory _scopeFactory;");
        sb.AppendLine("        private readonly ExperimentRegistration _registration;");
        sb.AppendLine("        private readonly IExperimentDecoratorFactory[] _decoratorFactories;");
        sb.AppendLine("        private readonly IExperimentTelemetry _telemetry;");
    }

    private static void AppendConstructor(StringBuilder sb, string className)
    {
        sb.AppendLine($"        public {className}(");
        sb.AppendLine("            Microsoft.Extensions.DependencyInjection.IServiceScopeFactory scopeFactory,");
        sb.AppendLine("            ExperimentRegistration registration,");
        sb.AppendLine("            IExperimentDecoratorFactory[] decoratorFactories,");
        sb.AppendLine("            IExperimentTelemetry telemetry)");
        sb.AppendLine("        {");
        sb.AppendLine("            _scopeFactory = scopeFactory ?? throw new ArgumentNullException(nameof(scopeFactory));");
        sb.AppendLine("            _registration = registration ?? throw new ArgumentNullException(nameof(registration));");
        sb.AppendLine("            _decoratorFactories = decoratorFactories ?? throw new ArgumentNullException(nameof(decoratorFactories));");
        sb.AppendLine("            _telemetry = telemetry ?? throw new ArgumentNullException(nameof(telemetry));");
        sb.AppendLine("        }");
    }

    private static void AppendMethods(StringBuilder sb, ExperimentDefinitionModel experiment)
    {
        // Get all methods from the service interface (including inherited)
        var methods = GetAllInterfaceMethods(experiment.ServiceType);

        var isFirst = true;
        foreach (var method in methods)
        {
            if (!isFirst)
            {
                sb.AppendLine();
            }

            isFirst = false;

            MethodGenerator.GenerateMethod(sb, method, experiment);
        }
    }

    private static void AppendSelectionHelper(StringBuilder sb, ExperimentDefinitionModel experiment)
        => SelectionModeGenerator.GenerateSelectionHelper(sb, experiment);

    private static void AppendErrorPolicyHelper(StringBuilder sb, ExperimentDefinitionModel experiment)
        => ErrorPolicyGenerator.GenerateErrorPolicyHelper(sb, experiment);

    /// <summary>
    /// Gets all methods from an interface, including inherited interface methods.
    /// Excludes property accessors, event accessors, and other special methods.
    /// </summary>
    private static IEnumerable<IMethodSymbol> GetAllInterfaceMethods(INamedTypeSymbol interfaceType)
        => interfaceType.GetMembers()
            .Cast<object>()
            .Where(m => m is IMethodSymbol { MethodKind: MethodKind.Ordinary, IsStatic: false })
            .Select(m => m as IMethodSymbol)
            .Cast<IMethodSymbol>()
            .Union(
                interfaceType.AllInterfaces
                    .SelectMany(i => i.GetMembers())
                    .Where(m => m is IMethodSymbol { MethodKind: MethodKind.Ordinary, IsStatic: false })
                    .Cast<IMethodSymbol>(),
                SymbolEqualityComparer.Default)
            .Cast<IMethodSymbol>();
}
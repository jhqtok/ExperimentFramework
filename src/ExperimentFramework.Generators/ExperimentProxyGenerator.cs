using ExperimentFramework.Generators.Analyzers;
using ExperimentFramework.Generators.CodeGen;
using ExperimentFramework.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ExperimentFramework.Generators;

/// <summary>
/// Source generator that produces compile-time proxies for ExperimentFramework.
/// </summary>
[Generator]
public sealed class ExperimentProxyGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the incremental source generator with syntax providers for discovering experiment definitions.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Pipeline 1: Find .UseSourceGenerators() fluent API calls
        var fluentApiDefinitions = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsUseSourceGeneratorsCandidate(node),
                transform: static (ctx, _) => FluentApiAnalyzer.ExtractDefinitions(ctx))
            .Where(static definitions => definitions is not null);

        // Pipeline 2: Find [ExperimentCompositionRoot] attributes
        var attributeDefinitions = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCompositionRootAttributeCandidate(node),
                transform: static (ctx, _) => AttributeAnalyzer.ExtractDefinitions(ctx))
            .Where(static definitions => definitions is not null);

        // Combine both pipelines and generate proxies
        var allDefinitions = fluentApiDefinitions.Collect()
            .Combine(attributeDefinitions.Collect());

        context.RegisterSourceOutput(allDefinitions,
            static (sourceContext, definitions) => GenerateProxies(sourceContext, definitions));
    }

    /// <summary>
    /// Fast syntax filter: Check if node could be a UseSourceGenerators() call.
    /// </summary>
    private static bool IsUseSourceGeneratorsCandidate(SyntaxNode node)
    {
        // Look for invocations that might be .UseSourceGenerators()
        return node is InvocationExpressionSyntax invocation &&
               invocation.Expression is MemberAccessExpressionSyntax memberAccess &&
               memberAccess.Name.Identifier.Text == "UseSourceGenerators";
    }

    /// <summary>
    /// Fast syntax filter: Check if node could be a method with [ExperimentCompositionRoot].
    /// </summary>
    private static bool IsCompositionRootAttributeCandidate(SyntaxNode node)
    {
        // Look for methods with attributes
        return node is MethodDeclarationSyntax method &&
               method.AttributeLists.Count > 0;
    }

    /// <summary>
    /// Generate proxy classes for all discovered experiments.
    /// </summary>
    private static void GenerateProxies(
        SourceProductionContext context,
        (ImmutableArray<ExperimentDefinitionCollection?> fluent, ImmutableArray<ExperimentDefinitionCollection?> attributes) definitions)
    {
        // Combine all definitions from both sources
        var allExperiments = definitions.fluent
            .Concat(definitions.attributes)
            .Where(d => d is not null)
            .SelectMany(d => d!.Definitions)
            .GroupBy(d => d.ServiceType.ToDisplayString())
            .Select(g => g.First())
            .ToImmutableArray();

        // Generate diagnostic summary for debugging
        var diagSummary = new StringBuilder();
        diagSummary.AppendLine("// <auto-generated />");
        diagSummary.AppendLine($"// ExperimentFramework Source Generator Diagnostic");
        diagSummary.AppendLine($"// Fluent API collections found: {definitions.fluent.Length}");
        diagSummary.AppendLine($"// Attribute collections found: {definitions.attributes.Length}");

        var fluentDefCount = definitions.fluent.Sum(d => d?.Definitions.Length ?? 0);
        var attrDefCount = definitions.attributes.Sum(d => d?.Definitions.Length ?? 0);
        diagSummary.AppendLine($"// Total fluent definitions: {fluentDefCount}");
        diagSummary.AppendLine($"// Total attribute definitions: {attrDefCount}");
        diagSummary.AppendLine($"// Total experiments after deduplication: {allExperiments.Length}");
        diagSummary.AppendLine("//");

        // Debug: Show details about what was found
        diagSummary.AppendLine("// Debug - Fluent collections:");
        for (var i = 0; i < definitions.fluent.Length; i++)
        {
            var fc = definitions.fluent[i];
            if (fc != null)
            {
                diagSummary.AppendLine($"//   Collection {i}: {fc.Definitions.Length} definitions");
                foreach (var def in fc.Definitions)
                {
                    diagSummary.AppendLine($"//     - {def.ServiceType.ToDisplayString()}");
                }
            }
            else
            {
                diagSummary.AppendLine($"//   Collection {i}: null");
            }
        }

        if (allExperiments.Length > 0)
        {
            diagSummary.AppendLine("// Discovered experiments:");
            foreach (var exp in allExperiments)
            {
                diagSummary.AppendLine($"//   - {exp.ServiceType.Name} ({exp.SelectionMode})");
            }
        }

        context.AddSource("_Diagnostic.g.cs", diagSummary.ToString());

        if (allExperiments.Length == 0)
            return;

        // Generate a proxy class for each experiment
        foreach (var experiment in allExperiments)
        {
            try
            {
                var proxyClassName = ProxyClassBuilder.GetProxyClassName(experiment.ServiceType);
                var proxySource = ProxyClassBuilder.GenerateProxyClass(experiment);

                context.AddSource($"{proxyClassName}.g.cs", proxySource);
            }
            catch (System.Exception ex)
            {
                // Report diagnostic if proxy generation fails
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "EXPFR001",
                        "Proxy generation failed",
                        $"Failed to generate proxy for {experiment.ServiceType.ToDisplayString()}: {ex.Message}",
                        "ExperimentFramework",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None));
            }
        }
    }
}

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ExperimentFramework.Generators.Schema;

/// <summary>
/// Source generator that produces schema stamping and versioning metadata at build time.
/// Discovers configuration model types and generates deterministic hashes and versions.
/// </summary>
[Generator]
public sealed class ConfigSchemaGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the incremental source generator for schema stamping.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes in the Models namespace that represent configuration
        var configModels = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsConfigurationModelCandidate(node),
                transform: static (ctx, _) => ExtractConfigurationModel(ctx))
            .Where(static model => model is not null);

        // Collect all models and generate schema
        var allModels = configModels.Collect();

        context.RegisterSourceOutput(allModels,
            static (sourceContext, models) => GenerateSchema(sourceContext, models!));
    }

    /// <summary>
    /// Fast syntax filter: Check if node could be a configuration model class.
    /// </summary>
    private static bool IsConfigurationModelCandidate(SyntaxNode node)
    {
        // Look for classes that end with "Config" or are in a "Models" namespace
        if (node is not ClassDeclarationSyntax classDecl)
        {
            return false;
        }

        var className = classDecl.Identifier.Text;
        return className.EndsWith("Config") || 
               className.EndsWith("Configuration") ||
               className.EndsWith("Options") ||
               className.EndsWith("Settings");
    }

    /// <summary>
    /// Extract configuration model information from syntax context.
    /// </summary>
    private static ConfigurationModelInfo? ExtractConfigurationModel(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax classDecl)
        {
            return null;
        }

        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
        if (symbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        // Only process public classes in certain namespaces
        if (typeSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return null;
        }

        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        
        // Filter to ExperimentFramework configuration types
        if (!namespaceName.Contains("ExperimentFramework") || 
            (!namespaceName.Contains(".Models") && 
             !namespaceName.Contains(".Configuration") &&
             !namespaceName.Contains(".Options")))
        {
            return null;
        }

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Select(p => new PropertyInfo
            {
                Name = p.Name,
                TypeName = p.Type.ToDisplayString(),
                IsRequired = IsRequired(p),
                IsNullable = p.NullableAnnotation == NullableAnnotation.Annotated
            })
            .ToImmutableArray();

        return new ConfigurationModelInfo
        {
            TypeName = typeSymbol.Name,
            FullTypeName = typeSymbol.ToDisplayString(),
            Namespace = namespaceName,
            Properties = properties
        };
    }

    private static bool IsRequired(IPropertySymbol property)
    {
        // Check for [Required] attribute or non-nullable reference types
        var hasRequiredAttribute = property.GetAttributes()
            .Any(a => a.AttributeClass?.Name == "RequiredAttribute");

        var isNonNullableReference = property.Type.IsReferenceType &&
                                      property.NullableAnnotation == NullableAnnotation.NotAnnotated;

        return hasRequiredAttribute || isNonNullableReference;
    }

    /// <summary>
    /// Generate schema metadata and hashing code.
    /// </summary>
    private static void GenerateSchema(
        SourceProductionContext context,
        ImmutableArray<ConfigurationModelInfo?> models)
    {
        var validModels = models.Where(m => m is not null).ToImmutableArray();
        
        // Always generate a diagnostic file to confirm generator is running
        var diagnosticSb = new StringBuilder();
        diagnosticSb.AppendLine("// <auto-generated />");
        diagnosticSb.AppendLine($"// ConfigSchemaGenerator Diagnostic - {System.DateTimeOffset.UtcNow:O}");
        diagnosticSb.AppendLine($"// Total models found: {validModels.Length}");
        diagnosticSb.AppendLine("// Models:");
        foreach (var model in validModels)
        {
            diagnosticSb.AppendLine($"//   - {model!.FullTypeName}");
        }
        context.AddSource("SchemaGeneratorDiagnostic.g.cs", diagnosticSb.ToString());
        
        if (validModels.Length == 0)
        {
            return;
        }

        // Group by namespace to determine extensions
        var extensionGroups = validModels
            .Select(m => m!)
            .GroupBy(m => GetExtensionName(m.Namespace))
            .ToImmutableArray();

        // Generate one class per extension
        foreach (var group in extensionGroups)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// ExperimentFramework Schema Generation");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            
            GenerateExtensionSchema(sb, group.Key, group.ToImmutableArray());
            
            context.AddSource($"{SanitizeIdentifier(group.Key)}Schema.g.cs", sb.ToString());
        }

        // Generate unified schema accessor in a separate file
        var unifiedSb = new StringBuilder();
        unifiedSb.AppendLine("// <auto-generated />");
        unifiedSb.AppendLine("// ExperimentFramework Schema Generation");
        unifiedSb.AppendLine("#nullable enable");
        unifiedSb.AppendLine();
        unifiedSb.AppendLine("using System;");
        unifiedSb.AppendLine("using System.Collections.Generic;");
        unifiedSb.AppendLine("using System.Linq;");
        unifiedSb.AppendLine();
        
        GenerateUnifiedSchemaAccessor(unifiedSb, extensionGroups);
        
        context.AddSource("SchemaRegistry.g.cs", unifiedSb.ToString());
    }

    private static void GenerateExtensionSchema(
        StringBuilder sb,
        string extensionName,
        ImmutableArray<ConfigurationModelInfo> models)
    {
        // Calculate normalized schema representation
        var normalizedSchema = NormalizeModels(models);
        var schemaHash = ComputeFnv1aHash(normalizedSchema);

        sb.AppendLine($"namespace ExperimentFramework.Configuration.Schema.Generated;");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated schema metadata for {extensionName}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public static class {SanitizeIdentifier(extensionName)}Schema");
        sb.AppendLine("{");
        sb.AppendLine($"    /// <summary>Schema hash computed at build time</summary>");
        sb.AppendLine($"    public const string SchemaHash = \"{schemaHash:x16}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Extension name</summary>");
        sb.AppendLine($"    public const string ExtensionName = \"{extensionName}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Normalized schema representation</summary>");
        sb.AppendLine($"    public const string NormalizedSchema = @\"{EscapeString(normalizedSchema)}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Types included in this schema</summary>");
        sb.AppendLine($"    public static readonly string[] Types = new[]");
        sb.AppendLine($"    {{");
        foreach (var model in models)
        {
            sb.AppendLine($"        \"{model.FullTypeName}\",");
        }
        sb.AppendLine($"    }};");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateUnifiedSchemaAccessor(
        StringBuilder sb,
        ImmutableArray<IGrouping<string, ConfigurationModelInfo>> extensionGroups)
    {
        sb.AppendLine("namespace ExperimentFramework.Configuration.Schema.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Provides access to all generated schema metadata.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class SchemaRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets all extension schema hashes.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IReadOnlyDictionary<string, string> ExtensionHashes { get; } = new Dictionary<string, string>");
        sb.AppendLine("    {");
        
        foreach (var group in extensionGroups)
        {
            var sanitized = SanitizeIdentifier(group.Key);
            sb.AppendLine($"        {{ \"{group.Key}\", {sanitized}Schema.SchemaHash }},");
        }
        
        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the unified hash of all schemas.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static string UnifiedHash { get; } = ComputeUnifiedHash();");
        sb.AppendLine();
        sb.AppendLine("    private static string ComputeUnifiedHash()");
        sb.AppendLine("    {");
        sb.AppendLine("        var hashes = ExtensionHashes.Values.OrderBy(h => h).ToArray();");
        sb.AppendLine("        var combined = string.Join(\"|\", hashes);");
        sb.AppendLine("        return ComputeHash(combined);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static string ComputeHash(string input)");
        sb.AppendLine("    {");
        sb.AppendLine("        const ulong FnvOffsetBasis = 14695981039346656037UL;");
        sb.AppendLine("        const ulong FnvPrime = 1099511628211UL;");
        sb.AppendLine("        var hash = FnvOffsetBasis;");
        sb.AppendLine("        foreach (var b in System.Text.Encoding.UTF8.GetBytes(input))");
        sb.AppendLine("        {");
        sb.AppendLine("            hash ^= b;");
        sb.AppendLine("            hash *= FnvPrime;");
        sb.AppendLine("        }");
        sb.AppendLine("        return hash.ToString(\"x16\");");
        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private static string GetExtensionName(string namespaceName)
    {
        // Extract extension name from namespace
        // e.g., "ExperimentFramework.Configuration.Models" -> "Configuration"
        var parts = namespaceName.Split('.');
        if (parts.Length >= 2 && parts[0] == "ExperimentFramework")
        {
            return parts[1];
        }
        return "Core";
    }

    private static string SanitizeIdentifier(string name)
    {
        // Remove invalid characters for C# identifiers
        return new string(name.Where(c => char.IsLetterOrDigit(c) || c == '_').ToArray());
    }

    private static string EscapeString(string value)
    {
        return value.Replace("\"", "\"\"");
    }

    private static string NormalizeModels(ImmutableArray<ConfigurationModelInfo> models)
    {
        var sb = new StringBuilder();
        
        foreach (var model in models.OrderBy(m => m.TypeName))
        {
            sb.AppendLine($"TYPE:{model.TypeName}");
            sb.AppendLine($"NAMESPACE:{model.Namespace}");
            
            foreach (var prop in model.Properties.OrderBy(p => p.Name))
            {
                sb.AppendLine($"  PROP:{prop.Name}");
                sb.AppendLine($"  TYPE:{prop.TypeName}");
                sb.AppendLine($"  REQUIRED:{prop.IsRequired}");
                sb.AppendLine($"  NULLABLE:{prop.IsNullable}");
            }
            sb.AppendLine();
        }
        
        return sb.ToString().TrimEnd();
    }

    private static ulong ComputeFnv1aHash(string content)
    {
        const ulong FnvOffsetBasis = 14695981039346656037UL;
        const ulong FnvPrime = 1099511628211UL;
        
        var hash = FnvOffsetBasis;
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        
        foreach (var b in bytes)
        {
            hash ^= b;
            hash *= FnvPrime;
        }
        
        return hash;
    }
}

internal sealed class ConfigurationModelInfo
{
    public string TypeName { get; set; } = string.Empty;
    public string FullTypeName { get; set; } = string.Empty;
    public string Namespace { get; set; } = string.Empty;
    public ImmutableArray<PropertyInfo> Properties { get; set; }
}

internal sealed class PropertyInfo
{
    public string Name { get; set; } = string.Empty;
    public string TypeName { get; set; } = string.Empty;
    public bool IsRequired { get; set; }
    public bool IsNullable { get; set; }
}
